### 2013年蓝桥杯

#### 世纪的末期

曾有邪教称1999年12月31日是世界末日。当然该谣言已经不攻自破。

还有人称今后的某个世纪末的12月31日，如果是星期一则会....

有趣的是，任何一个世纪末的年份的12月31日都不可能是星期一!! 

于是，“谣言制造商”又修改为星期日......

1999年的12月31日是星期五，请问：未来哪一个离我们最近的一个世纪末年（即xx99年）的12月31日正好是星期天（即星期日）？

**java中有多种日期的api**

**注意，题目中的坑，这里定义1999年12月31日是星期五，但是可能事实上这一天并不是星期五**

```java
import java.util.Calendar;
/*
要熟悉日期的api，1970年之前不行
 */
public class a {
    public static void main(String[] args) {
        Calendar calendar=Calendar.getInstance();//获取日期的实例
        for(int i=1999;i<10000;i+=100){//因为这是一个世纪末，所以要100年加减
            calendar.set(Calendar.YEAR,i);//传两个参数，第一个是设置的项，第二个是要传进去的值
            calendar.set(Calendar.MONTH,11);//注意这里的月份是11,从0开始
            calendar.set(Calendar.DAY_OF_MONTH,31);//从1开始
            
            //calendar.set(i,11,31);也可以只使用一行代码完成
            
            //calendar.get(Calendar.DAY_OF_WEEK);//每一天在一周中是星期几，星期日是第一天=1
            if(calendar.get(Calendar.DAY_OF_WEEK)==1){
                System.out.println(i);//2299
                break;
            }
        }
    }
}
```

#### 马虎的算式

小明是个急性子上小学的时候经常把老师写在黑板上的题目抄错了。 

有一次老师出的题目是36 x 495 = ? 

他却给抄成了396 x 45 = ? 

但结果却很戏剧性他的答案竟然是对的

因为 36 * 495 = 396 * 45 = 17820 

类似这样的巧合情况可能还有很多比如27 * 594 = 297 * 54 

假设 **a b c d e 代表1~9不同的5个数字注意是各不相同的数字且不含0**

能满足形如ab * cde = adb * ce 这样的算式一共有多少种呢

请你利用计算机寻找并回答不同算式的种类数，满足乘法交换律的算式记为不同的种类，所以答案肯定是一个偶数

**枚举法**

**可以把数值的各个位看成不同的部分，如果把数值看成一个整体，那么还要对数值进行拆分，相对比较麻烦**

```java
/*
使用五层循环枚举
 */
public class b {
    public static void main(String[] args) {
        int count=0;
        for(int a=1;a<10;a++){
            for(int b=1;b<10;b++){
                for(int c=1;c<10;c++){
                    for(int d=1;d<10;d++){
                        for(int e=1;e<10;e++){
                            //每个数都不相同
                            if(a!=b&&a!=e&&a!=c&&a!=d&&b!=c&&b!=d&&b!=e&&c!=d&&c!=e&&d!=e){
                                //构造算式
                                if((a*10+b)*(c*100+d*10+e)==(a*100+d*10+b)*(c*10+e)){
                                    count++;
                                }
                            }
                        }
                    }
                }
            }
        }
        System.out.println(count);//142
    }
}
```

#### 振兴中华

(递归求解)

小明参加了学校的趣味运动会，其中的一个项目是：跳格子。

地上画着一些格子，每个格子里写一个字，如下所示：（也可参见p1.jpg）

 从我做起振
 我做起振兴
 做起振兴中
 起振兴中华

比赛时，先站在左上角的写着“从”字的格子里，可以横向或纵向跳到相邻的格子里，但不能跳到对角的格子或其它位置。一直要跳到“华”字结束。

要求跳过的路线刚好构成“从我做起振兴中华”这句话。

请你帮助小明算一算他一共有多少种可能的跳跃路线呢？

 答案是一个整数，请通过浏览器直接提交该数字。

 注意：不要提交解答过程，或其它辅助说明类的内容

**向右下角跳跃，向右或向下，边界终止**

**可以沿着任一方向**

**普通的伸收，dfs**

**递归：重复，变化，边界**

```java
public class c {
    public static void main(String[] args) {
        //初始
        int result=f(0,0);
        System.out.println(result);//35
    }

    public static int f(int i,int j){
        //向下向右，或 向右向下

        if(i==3||j==4){
            return 1;
        }
        return f(i+1,j)+f(i,j+1);//将两种走法的线路数相加
    }
}
```

#### 黄金连分数

黄金分割数0.61803... 是个无理数，这个常数十分重要，在许多工程问题中会出现。有时需要把这个数字求得很精确。
对于某些精密工程，常数的精度很重要。也许你听说过哈勃太空望远镜，它首次升空后就发现了一处人工加工错误，对那样一个庞然大物，其实只是镜面加工时有比头发丝还细许多倍的一处错误而已，却使它成了“近视眼”!!
言归正传，我们如何求得黄金分割数的尽可能精确的值呢？有许多方法。
比较简单的一种是用连分数：

```
              1
黄金数 = ---------------------
                    1
         1 + -----------------
                      1
             1 + -------------
                        1
                 1 + ---------
                      1 + ...
```

这个连分数计算的“层数”越多，它的值越接近黄金分割数。
请你利用这一特性，求出黄金分割数的足够精确值，要求四舍五入到小数点后100位。
小数点后3位的值为：0.618
小数点后4位的值为：0.6180
小数点后5位的值为：0.61803
小数点后7位的值为：0.6180340
（注意尾部的0，不能忽略）
你的任务是：写出精确到小数点后100位精度的黄金分割值。
注意：尾数的四舍五入！ 尾数是0也要保留！
显然答案是一个小数，其小数点后有100位数字，请通过浏览器直接提交该数字。

注意：不要提交解答过程，或其它辅助说明类的内容。

**递归：数值越来越麻烦**

**或者化为分数**：1/2，2/3，3/5，5/8，……，符合斐波那契数列，即求斐波那契数列相邻的比值

**思路：**

- 求斐波那契数列相邻两项的比值，
- 求到多少项，项数越多越精确，n/n+1，n再增加，比值的小数点后100位是稳定的，也就是不变的
- 定义为double也最多只能显示16位，无法表示100位的小数，要用到高阶表示法：BigInteger,BigDecimal
- BigDecimal，用来对超过16位有效位的数进行精确的运算
- 要会用API

```java
import java.math.BigDecimal;
import java.math.BigInteger;

public class d {
    public static void main(String[] args) {
        BigInteger a=BigInteger.ONE;
        BigInteger b=BigInteger.ONE;
        for(int i=3;i<400;i++){
            BigInteger t=b;
            b=a.add(b);//相加
            a=t;
        }
        BigDecimal devide=new BigDecimal(a,110).divide(new BigDecimal(b,110),BigDecimal.ROUND_HALF_DOWN);//定义时要指定有多少位数
        System.out.println(devide.toPlainString().substring(0,103));//取前103位，包括个位和小数点，最后的一位是用来四舍五入
    }

    /*
    i<100:0.61803398874989484820458683436563811772029984871889165393979351592049489133579852579526037628096059805
    i<200:0.61803398874989484820458683436563811772030917980576286213544862270526046281890244969233401224637257135
    i<300:0.61803398874989484820458683436563811772030917980576286213544862270526046281890244970720720418939113748
    i<400:0.61803398874989484820458683436563811772030917980576286213544862270526046281890244970720720418939113748
    
    所以最终的答案：0.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911375
     */
}
```

#### 有理数类

有理数就是可以表示为两个整数的比值的数字。一般情况下，我们用近似的小数表示。但有些
时候，不允许出现误差，必须用两个整数来表示一个有理数。

这时，我们可以建立一个“有理数类”，下面的代码初步实现了这个目标。为了简明，它只提
供了加法和乘法运算。

```java
class Rational
{
private long ra;
private long rb;

private long gcd(long a, long b){
if(b==0) return a;
return gcd(b,a%b);
}
public Rational(long a, long b){
ra = a;
rb = b;	
long k = gcd(ra,rb);
if(k>1){ //需要约分
ra /= k; 
rb /= k;
}
}
// 加法
public Rational add(Rational x){
return  ; //填空位置
}
// 乘法
public Rational mul(Rational x){
return new Rational(ra*x.ra, rb*x.rb);
}
public String toString(){
if(rb==1) return "" + ra;
return ra + "/" + rb;
}
}

使用该类的示例：
Rational a = new Rational(1,3);
Rational b = new Rational(1,6);
Rational c = a.add(b);
System.out.println(a + "+" + b + "=" + c);
```

答案：

```java
// 加法
        public Rational add(Rational x){
            return  new Rational(this.ra+x.rb+this.rb+x.ra,x.rb*this.rb); //填空位置,注意分数的运算步骤和过程
        }
```



#### 三部排序

一般的排序有许多经典算法，如快速排序、希尔排序等。

但实际应用时，经常会或多或少有一些特殊的要求。我们没必要套用那些经典算法，可以根据实际情况建立更好的解法。

比如，对一个整型数组中的数字进行分类排序：

使得负数都靠左端，正数都靠右端，0在中部。注意问题的特点是：负数区域和正数区域内并不要求有序。可以利用这个特点通过1次线性扫描就结束战斗!!

以下的程序实现了该目标。

其中x指向待排序的整型数组，len是数组的长度。

```java
static void sort(int[] x)
	{
		int p = 0;
		int left = 0;//下标
		int right = x.length-1;//最大下标
		
		while(p<=right){
            //元素小于0，将元素和left位置交换
			if(x[p]<0){
				int t = x[left];
				x[left] = x[p];
				x[p] = t;
				left++;
				p++;
			}
            //元素大于0，将元素和right位置交换
			else if(x[p]>0){
				int t = x[right];
				x[right] = x[p];
				x[p] = t;
				right--;			
			}
            //元素等于0
			else{
				p++;  //代码填空位置
			}
		}
	}


```

**分析：利用归并的思想，分为三部分排序**

**类似于荷兰国旗问题**

#### 错误票据

某涉密单位下发了某种票据，并要在年终全部收回。

每张票据有唯一的ID号。全年**所有票据的ID号是连续**的，但ID的**开始数码是随机**选定的。

因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。

你的任务是通过编程，找出断号的ID和重号的ID。

假设断号不可能发生在最大和最小号。

要求程序首先输入一个整数N(N<100)表示后面数据行数。

   接着读入N行数据。
   每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000）
   每个整数代表一个ID号。

   要求程序输出1行，含两个整数m n，用空格分隔。
   其中，m表示断号ID，n表示重号ID



例如：
用户输入：
2
5 6 8 11 9 
10 12 9
则程序输出：
7 9

再例如：
用户输入：
6
164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196
172 189 127 107 112 192 103 131 133 169 158 
128 102 110 148 139 157 140 195 197
185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190
149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188
113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119
则程序输出：
105 120

资源约定：
峰值内存消耗 < 64M
CPU消耗  < 1000ms

请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。

提交时，注意选择所期望的编译器类型。

**50分**

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class f {
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        //数组长度不确定
        ArrayList<Integer> list=new ArrayList<>();
        int n=scanner.nextInt();
        scanner.nextLine();//输入时有换行符，这里是吃掉整数后面的换行符
        for(int i=0;i<n;i++){
            String line=scanner.nextLine();
            String[] split=line.split(" ");
            for(int j=0;j<split.length;j++){
                list.add(Integer.parseInt(split[j]));
            }
        }

        //对list进行排序
        Collections.sort(list);
        //看哪里是断的，哪里是重的
        int a=0,b=0;
        for(int i=1;i<list.size();i++){
            //断
            if(list.get(i)-list.get(i-1)==2){
                a=list.get(i)-1;
            }
            //重复
            if(list.get(i)==list.get(i-1)){
                b=list.get(i);
            }
        }
        System.out.println(a+" "+b);
    }
}
```

**注意，从集合中取出数据是对象，如果是比较对象是否相同，要用equals**

```java
for(int i=1;i<list.size();i++){
    //断
    if(list.get(i)-list.get(i-1)==2){
        a=list.get(i)-1;
    }
    //重复
    if(list.get(i).equals(list.get(i-1))){
        b=list.get(i);
    }
}
```

#### 幸运数

幸运数是波兰数学家乌拉姆命名的。它采用与生成素数类似的“筛法”生成。

首先从1开始写出自然数1,2,3,4,5,6,....

1 就是第一个幸运数。

我们从2这个数开始。把所有序号能被2整除的项删除，变为：

1 _ 3 _ 5 _ 7 _ 9 ....

把它们缩紧，重新记序，为：

1 3 5 7 9 .... 。这时，3为第2个幸运数，然后把所有能被3整除的序号位置的数删去。注意，是序号位置，不是那个数本身能否被3整除!! 删除的应该是5，11, 17, ...

此时7为第3个幸运数，然后再删去序号位置能被7整除的(19,39,...)

最后剩下的序列类似：

1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, ...

输入格式
输入两个正整数m n, 用空格分开 (m < n < 1000*1000)
输出格式
程序输出 位于m和n之间的幸运数的个数（不包含m和n）。
样例输入
1 20
样例输出
5

样例输入
30 69
样例输出

8

